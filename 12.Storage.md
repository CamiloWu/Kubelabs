# 14. Storage <!-- omit in TOC -->

> [Documentación Oficial](https://kubernetes.io/docs/concepts/storage/volumes/)

> La configuración de este laboratorio NO debe ser aplicada en ambientes productivos.
>
> La recomendación es utilizar un almacenamiento externo al Worker Node!

# 1. Parte 1: Crear un nuevo Pod pod-storage.yml
> [kubelabs-files-demo/pod-storage.yml](./kubelabs-files-demo/pod-storage.yml)

> [hostpath](https://kubernetes.io/docs/concepts/storage/volumes/#hostpath)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-storage
  labels:
    app: pod-storage
spec:
  containers:
    - name: nginx-container
      image: nginx
      ports:
        - containerPort: 80
      volumeMounts:
        - name: static-vol
          mountPath: /usr/share/nginx/html/ # destino dentro del Pod
  volumes:
    - name: static-vol
      hostPath:
        # el PATH debe existir en el WORKER NODE
        # evitar este tipo de Storage y sustituir por algún tipo de Storage fuera del Worker Node.        #
        path: /home/kube/kubelabs/kubelabs-files-demo/12
---
apiVersion: v1
kind: Service
metadata:
  name: pod-storage-svc
spec:
  type: NodePort
  ports:
    - targetPort: 80
      port: 80
      # nodePort: Si no define el NodePort, Kubernetes asigna un puerto aleatorio entre 30000-32768
  selector:
    app: pod-storage
```

> Revisar configuración de **volumeMounts**

> Revisar configuración de **volumes**

## 1.1. Ejecutar el pod utilizando el archivo pod-storage.yml
```vim
kubectl apply -f pod-storage.yml
```
> El archivo incluye un ***service*** en un puerto aleatorio

##

## 1.2. Validar el volumen montado en el pod

```vim
kubectl describe pods pod-storage
```
En la sección ***Containers*** ver la información del punto de montaje:
~~~~
Containers:
...
Mounts:
	/usr/share/nginx/html/ from static-vol (rw)
~~~~
En la sección ***Volumes*** ver la información del volumen tipo HostPath:
~~~~
Volumes:
  static-vol:
    Type:          HostPath (bare host directory volume)
    Path:          /home/kube/kubelabs/kubelabs-files-demo/12
~~~~

## 1.3. Listar el NodePort del pod y probar.
```vim
kubectl describe service pod-storage-svc | grep NodePort

```

## 1.4. Ingresar al pod
```vim
kubectl exec --stdin --tty pod-storage -- /bin/bash
```
### 1.4.1. Navegar a /usr/share/nginx/html/
Comprobar archivo html

# 2. probar en browser (http):

> http://<'ip-public'>:<'nodePort'>

## 2.1. Opcional, cambiar el contenido del archivo html
Conectar por SSH al servidor y cambiar el contenido del archivo html.

Cambiar la línea 21 del archivo: [kubelabs-files-demo/12/index.html](./kubelabs-files-demo/12/index.html)

# 3. Agregar un volumen persistente tipo HostPath

> [Documentación Persistent Volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)

Para almacenar las salidas de los logs Nginx (/var/nginx/logs), agregar un volumen persistente dentro del Nodo

## 3.1. Ejecutar el archivo static-pv.yml
> [kubelabs-files-demo/static-pv.yml](./kubelabs-files-demo/static-pv.yml)

```vim
kubectl apply -f kubelabs-files-demo/static-pv.yml
```

## 3.2. Desplegar el volumen persistente
```vim
kubectl get pv
```

Resultado:
> El PV queda en estado ***Available*** y de forma predeterminada le asignamo un ***CLAIM*** = static-pvc
~~~~
NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS        CLAIM
pv-static   100Mi      RWX            Retain           Available     default/static-pvc
~~~~

## 3.3. Reclamar el espacio con un PVC.

> [Documentación Oficial](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims)

Ejecutar el archivo static-pvc.yml
> [kubelabs-files-demo/static-pvc.yml](./kubelabs-files-demo/static-pvc.yml)

```vim
kubectl apply -f kubelabs-files-demo/static-pvc.yml
```
## 3.4. Listar el PVC y el PV

Comprobar que el espacio del PV ha sido reclamado

```vim
kubectl get pvc
```
Resultado:
> Status: ***Bound***, se han "conectado" el PVC y el PV reclamando efectivamente el espacio del disco.

> En caso de aparecer ***Pending*** se debe a que el PVC no ha encontrado un volumen con la capacidad y modo de acceso requeridos.

~~~~
NAME         STATUS        VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   AGE
static-pvc   Bound         static-pv   100Mi      RWX                           4s
~~~~

Validar el PV:
```vim
kubectl get pv
```
Resultado:
> Status: ***Bound***
~~~~
NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS        CLAIM
static-pv   100Mi      RWX            Retain           Bound         default/static-pvc
~~~~

## 3.5. Crear un Pod que utilice el PVC

Ejecutar el archivo static-pod-pvc.yml
> [kubelabs-files-demo/static-pod-pvc.yml](./kubelabs-files-demo/static-pod-pvc.yml)

```vim
kubectl apply -f kubelabs-files-demo/static-pod-pvc.yml
```
## 3.6. Listar Pod
```vim
kubectl describe pods static-pod
```
Resultado:
~~~~
Mounts:
	/usr/share/nginx/html/ from static-vol (rw)
	/var/log/nginx from web-claim (rw)
...
Volumes:
  static-vol:
    Type:          HostPath (bare host directory volume)
    Path:          /home/kube/kubelabs/kubelabs-files-demo/12
  web-claim:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  static-pvc
    ReadOnly:   false
~~~~

## 3.7. Opcional: probar el almacenamiento local /logs
```vim
tail -f /logs/access.log

# crear tráfico en browser
<ip-publica>:<nodePort>
```


# 4. Storage Class

## 4.1. Crear el storage class utilizando el archivo storage-class-gce.yml

> [Documentación Ofcial](https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/)

> [kubelabs-files-demo/storage-class-gce.yml](./kubelabs-files-demo/storage-class-gce.yml)

 ```vim
 kubectl apply -f kubelabs-files-demo/storage-class-gce.yml
 ```

 ```vim
 kubectl get sc
 ```

Resultado:
~~~~
NAME                          PROVISIONER            RECLAIMPOLICY   VOLUMEBINDINGMODE    ALLOWVOLUMEEXPANSION   AGE
democlass                     kubernetes.io/gce-pd   Delete          WaitForFirstConsumer false                  3s
~~~~

```vim
kubectl describe pvc auto-pvc
```
Resultado: ***Pending***
~~~~
Name:          auto-pvc
Namespace:     default
StorageClass:  democlass
Status:        Pending
...
Events:
Type     Reason              Message
----     ------              -------
Warning  ProvisioningFailed  Failed to provision volume with StorageClass "democlass": invalid AccessModes [ReadWriteMany]: only AccessModes [ReadWriteOnce ReadOnlyMany] are supported
~~~~

## 4.2. Resolver el problema del PVC y ejecutar de nuevo


```vim
kubectl describe pvc auto-pvc
```
Resultado: Esperando el primer consumer (Pod)
~~~~
Events:
  Type    Reason                Age                From                         Message
  ----    ------                ----               ----                         -------
  Normal  WaitForFirstConsumer  8s (x8 over 103s)  persistentvolume-controller  waiting for first consumer...
~~~~

## 4.3. Ejecutar un Pod que consuma el auto-pvc

> [kubelabs-files-demo/storage-class-pod.yml](./kubelabs-files-demo/storage-class-pod.yml)

```vim
kubectl apply -f kubelabs-files-demo/storage-class-pod.yml
```

```vim
kubectl get pv
```
Resultado: Automaticamente nos crea el PV
~~~~
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS   REASON   AGE
pvc-b81ac32c-085d-4d05-ad4f-eee43dae2e9f   100Mi      RWO            Delete           Bound    default/auto-pvc     democlass               8m25s
~~~~

## 4.4. NFS

> Es necesario un servidor NFS y exportar la ruta /srv/nfs/mydata

Crear los objetos del NFS usando el archivo:

> [kubelabs-files-demo/nfs-pv.yml](./kubelabs-files-demo/nfs-pv.yml)

```vim
kubectl apply -f kubelabs-files-demo/nfs-pv.yml
```

Resultado:
~~~~
# 5. PV
nfs-pv                                     100Mi      RWX            Retain           Bound    default/nfs-pvc      nfs-storage             18m

# 6. PVC
nfs-pvc      Bound    nfs-pv                                     100Mi      RWX            nfs-storage    18m

# 7. POD
nfs-pod            1/1     Running   0          19m
~~~~
