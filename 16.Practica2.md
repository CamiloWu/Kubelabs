# 16. Práctica #2 Full Demo <!-- omit in TOC -->

> Escenario:

Se ha modernizado una aplicación monolítica separando sus componentes en microservicios, esta se compone de 4 aplicaciones que se comunican entre si.

Las imágenes de estos servicios fueron construidas y ahora tienen un requerimiento de infraestructura que soporte un sistema orquestado en contenedores.

Las aplicaciones se acceden por medio del dominio, donde USERLAB es el nombre de laboratorio asignado a cada estudiante, ejemplo: carlosxyz.kubelabs.tk

A continuación los requerimientos específicos de cada uno de los módulos.

# 1. Configuracion General

## 1.1. Todos los objetos Kubernetes deben ser creados en archivos YAML, con el objetivo de recrear la solución de forma automatizada y con el mínimo esfuerzo.

## 1.2. Opcional: instalar las extensiones de VSCode: YAML y Kubernetes.
## 1.3. Opcional: Revisar las configuraciones utilizando Lens o MicroK8s Dashboard.
## 1.4. Namespaces
Es requerido implementar dos grupos de objetos separados por los namespaces:
> public

> private

<details>
  <summary>Tips</summary>

  > [namespace](./kubelabs-files-demo/namespace-definition.yml)
</details>

# 2. Web Server

## 2.1. Debe se creado en el namespace ***public***
## 2.2. Se debe acceder por el dominio USERLAB.kubelabs.tk

## 2.3. Es una página web reactiva que para este caso, debe ser accedida por HTTP (puerto 80) y su contenedor escucha por el puerto 8080.

## 2.4. Necesita una ruta apuntando a su root (/)

## 2.5. Para efectos de alta disponibilidad se requieren 2 replicas
## 2.6. Dirección de la imagen:
> cachac/kubelabs_webapp:1.1.7

## 2.7. La página requiere montar un archivo de configuración con las siguientes características:
### 2.7.1. Ubicación del archivo:
> /home/kube/kubelabs/config.js

### 2.7.2. Editar el archivo agregando el subdominio de cada estudiante
> Sustituir las XXXXXXX con el nombre del SUBDOMINIO

### 2.7.3. Dentro del POD montar el archivo en la ruta:
> /usr/share/nginx/html/config.js

<details>
  <summary>Tips</summary>


> [Deployment](./kubelabs-files-demo/deployment-definition.yml)
>
> [ingress](./kubelabs-files-demo/ingress-definition.yml)
>
> [volumeMounts (ver líneas 43 a 50)](./kubelabs-files-demo/demo-ingress.yml)
</details>

# 3. Web Socket
## 3.1. Namespace ***public***

## 3.2. Este servicio se accede por la ruta websocket.USERLAB.kubelabs.tk
## 3.3. La ruta es /graphql

## 3.4. Puerto 3001

## 3.5. Replicas: 1

## 3.6. Imagen:
> cachac/kubelabs_websocket:1.0.6

## 3.7. Este es un servicio CRÍTICO que usa una variable de entorno para establecer la conexión con la página web:

> Nombre: TOKEN_SECRET
>
> Valor: PASS

<details>
  <summary>Tips</summary>

  > [secret](./kubelabs-files-demo/secret-definition.yml)
  >
	> [Pod secret línea 31](./kubelabs-files-demo/16/secret-demo-mysql.yml)
</details>

~~~~
								     				CHECK POINT #1
~~~~

# 4. Public API

## 4.1. Namespace ***public***

## 4.2. Este servicio se accede por la ruta api.USERLAB.kubelabs.tk
## 4.3. La ruta es /graphql

## 4.4. Puerto 3000

## 4.5. Replicas: 2

## 4.6. Imagen:
> cachac/kubelabs_publicapi:1.0.1

## 4.7. Utiliza una variable de entorno para establecer la conexión con el API privado:
> Crear la variable como configMap y EDITAR su valor posteriormente cuando se configure el API privado en el siguiente punto.

> Nombre: PRIVATE_API
>
> Valor: dirección del API Privado


<details>
  <summary>Tips</summary>

  > [configMap](./kubelabs-files-demo/configmap-definition.yml)
  >
	> [Pod secret línea 22](./kubelabs-files-demo/deploy-configmap.yml)
</details>


# 5. Private API

## 5.1. Namespace ***private***

## 5.2. Este servicio se accede por la ruta api.USERLAB.kubelabs.tk
## 5.3. La ruta es /graphql

## 5.4. Puerto 3002

## 5.5. Replicas: 1

## 5.6. Imagen:
cachac/kubelabs_privateapi:1.0.2

## 5.7. Editar el configMap (punto 4.7) con la dirección del api privado:

> Nombre: PRIVATE_API
>
> Valor: http://SERVICE.NAMESPACE.svc.cluster.local:3002/private

~~~~
								     				CHECK POINT #2
~~~~
# 6. Recursos
## 6.1. Página web
> limites: CPU: 100m; memoria: 100Mi
>
> requests: cpu: 10m; memoria: 50Mi

## 6.2. Websocket
> limites: CPU: 250m; memoria: 200Mi
>
> requests: cpu: 100m; memoria: 100Mi

## 6.3. Public API
> limites: CPU: 200m; memoria: 200Mi
>
> requests: cpu: 100m; memoria: 100Mi

## 6.4. Private API
> limites: CPU: 200m; memoria: 200Mi
>
> requests: cpu: 100m; memoria: 100Mi

# 7. HealthChecks

## 7.1. Websocket
> path: /healthcheck
>
>  puerto: 3081
>
> initialDelaySeconds: 10, periodSeconds: 30, timeoutSeconds: 5
## 7.2. Public API
> path: /healthcheck
>
>  puerto: 3080
>
> initialDelaySeconds: 10, periodSeconds: 30, timeoutSeconds: 5
## 7.3. Private API
> path: /healthcheck
>
>  puerto: 3082
>
> initialDelaySeconds: 10, periodSeconds: 30, timeoutSeconds: 5

~~~~
								     				CHECK POINT #3
~~~~

# 8. Logs
## 8.1. Public API
Los logs generados por este API deben ser almacenados persistentemente con los siguientes valores:

### 8.1.1. Namespace: public
### 8.1.2. Storage Class, aprovisionado por microk8s.io/hostpath
### 8.1.3. Los archivos deben mantenerse posterior a la eliminación del volumen
### 8.1.4. Escritura y lectura desde un único punto (RWO)
### 8.1.5. Almacenamiento 50Mi
### 8.1.6. Ruta del logs en el POD: /app/logs

<details>
  <summary>Tips</summary>

  > [storageClass - PVC](./kubelabs-files-demo/practica/sc-public-api.yml)
  >
	> [volumeMounts líneas 45 a 51](./kubelabs-files-demo/practica/public-api.yml)

</details>

## 8.2. Private API

Los logs generados por este API deben ser almacenados persistentemente FUERA del Control Plane utilizando un NFS con los siguientes valores:

### 8.2.1. Namespace: private
### 8.2.2. PersistentVolume tipo nfs
> server: Asignado por el tutor
>
> path: /srv/nfs/mydata/## (seleccionar un número de dos dígitos entre 01-25)
### 8.2.3. Los archivos deben mantenerse posterior a la eliminación del volumen
### 8.2.4. Escritura y lectura desde un único punto (RWO)
### 8.2.5. Almacenamiento 50Mi
### 8.2.6. Ruta del logs en el POD: /app/logs

<details>
  <summary>Tips</summary>

  > [NFS](./kubelabs-files-demo/practica/nfs-private-api.yml)
  >
	> [volumeMounts líneas 43 a 49](./kubelabs-files-demo/practica/private-api.yml)

</details>
# 9. Estatégias de deployment

## 9.1. La página web debe ser desplegada perdiendo hasta el 50% de los pods
## 9.2. Las réplicas del websocket deben ser eliminadas en su totalidad y recreadas con cada despliegue

<details>
  <summary>Tips</summary>

  > [strategy RollingUpdate](./kubelabs-files-demo/deploy-lifecycle.yml)
</details>

# 10. HPA
## 10.1. El API público es un servicio de alta demanda que debe crecer automaticamente cuando:
> el CPU sea superior al 35%
>
> la memoria sea superior al 50%
>
> minimo de replicas: 3
>
> máximo de replicas: 6
<details>
  <summary>Tips</summary>

  > [Deploy HPA línea 40](./kubelabs-files-demo/hpa-definition.yml)
</details>

~~~~
								     				FINAL
~~~~
